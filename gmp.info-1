This is Info file gmp.info, produced by Makeinfo version 1.68 from the
input file gmp.texi.

START-INFO-DIR-ENTRY
* gmp: (gmp.info).               GNU Multiple Precision Arithmetic Library.
END-INFO-DIR-ENTRY

   This file documents GNU MP, a library for arbitrary-precision
arithmetic.

   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1998 Free Software
Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: gmp.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

GNU MP
******

   This manual documents how to install and use the GNU multiple
precision arithmetic library, version 2.1.

* Menu:

* Copying::                   GMP Copying Conditions (LGPL).
* Introduction to MP::        Brief introduction to GNU MP.
* Installing MP::             How to configure and compile the MP library.
* MP Basics::                 What every MP user should now.
* Reporting Bugs::            How to usefully report bugs.
* Integer Functions::         Functions for arithmetic on signed integers.
* Rational Number Functions:: Functions for arithmetic on rational numbers.
* Floating-point Functions::  Functions for arithmetic on floats.
* Low-level Functions::       Fast functions for natural numbers.
* BSD Compatible Functions::  All functions found in BSD MP.
* Custom Allocation::         How to customize the internal allocation.

* Contributors::
* References::
* Concept Index::
* Function Index::


File: gmp.info,  Node: Copying,  Next: Introduction to MP,  Prev: Top,  Up: Top

GNU MP Copying Conditions
*************************

   This library is "free"; this means that everyone is free to use it
and free to redistribute it on a free basis.  The library is not in the
public domain; it is copyrighted and there are restrictions on its
distribution, but these restrictions are designed to permit everything
that a good cooperating citizen would want to do.  What is not allowed
is to try to prevent others from further sharing any version of this
library that they might get from you.

   Specifically, we want to make sure that you have the right to give
away copies of the library, that you receive source code or else can
get it if you want it, that you can change this library or use pieces
of it in new free programs, and that you know you can do these things.

   To make sure that everyone has such rights, we have to forbid you to
deprive anyone else of these rights.  For example, if you distribute
copies of the GNU MP library, you must give the recipients all the
rights that you have.  You must make sure that they, too, receive or
can get the source code.  And you must tell them their rights.

   Also, for our own protection, we must make certain that everyone
finds out that there is no warranty for the GNU MP library.  If it is
modified by someone else and passed on, we want their recipients to
know that what they have is not what we distributed, so that any
problems introduced by others will not reflect on our reputation.

   The precise conditions of the license for the GNU MP library are
found in the Library General Public License that accompany the source
code.


File: gmp.info,  Node: Introduction to MP,  Next: Installing MP,  Prev: Copying,  Up: Top

Introduction to GNU MP
**********************

   GNU MP is a portable library written in C for arbitrary precision
arithmetic on integers, rational numbers, and floating-point numbers.
It aims to provide the fastest possible arithmetic for all applications
that need higher precision than is directly supported by the basic C
types.

   Many applications use just a few hundred bits of precision; but some
applications may need thousands or even millions of bits.  MP is
designed to give good performance for both, by choosing algorithms
based on the sizes of the operands, and by carefully keeping the
overhead at a minimum.

   The speed of MP is achieved by using fullwords as the basic
arithmetic type, by using sophisticated algorithms, by including
carefully optimized assembly code for the most common inner loops for
many different CPUs, and by a general emphasis on speed (as opposed to
simplicity or elegance).

   There is carefully optimized assembly code for these CPUs: DEC
Alpha, Amd 29000, HPPA 1.0 and 1.1, Intel Pentium and generic x86,
Intel i960, Motorola MC68000, MC68020, MC88100, and MC88110,
Motorola/IBM PowerPC, National NS32000, IBM POWER, MIPS R3000, R4000,
SPARCv7, SuperSPARC, generic SPARCv8, and DEC VAX.  Some optimizations
also for ARM, Clipper, IBM ROMP (RT), and Pyramid AP/XP.

   This version of MP is released under a more liberal license than
previous versions.  It is now permitted to link MP to non-free
programs, as long as MP source code is provided when distributing the
non-free program.

   For up-to-date information on MP,
`http://www.matematik.su.se/~tege/gmp/', is a good place to look.

How to use this Manual
======================

   Everyone should read *Note MP Basics::.  If you need to install the
library yourself, you need to read *Note Installing MP::, too.

   The rest of the manual can be used for later reference, although it
is probably a good idea to glance through it.


File: gmp.info,  Node: Installing MP,  Next: MP Basics,  Prev: Introduction to MP,  Up: Top

Installing MP
*************

   To build MP, you first have to configure it for your CPU and
operating system.  You need a C compiler, preferably GCC, but any
reasonable compiler should work.  And you need a standard Unix `make'
program, plus some other standard Unix utility programs.

   (If you're on an MS-DOS machine, you can build MP using `make.bat'.
It requires that djgpp is installed.  It does not require
configuration, nor is `make' needed; `make.bat' both configures and
builds the library.)

   Here are the steps needed to install the library on Unix systems:

  1. In most cases, `./configure --target=cpu-vendor-os', should work
     both for native and cross-compilation.  If you get error messages,
     your machine might not be supported.

     If you want to compile in a separate object directory, cd to that
     directory, and prefix the configure command with the path to the
     MP source directory.  Not all `make' programs have the necessary
     features (VPATH) to support this.  In particular, SunOS and
     Slowaris `make' have bugs that makes them unable to build from a
     separate object directory.  Use GNU `make' instead.

     In addition to the standard cpu-vendor-os tuples, MP recognizes
     sparc8 and supersparc as valid CPU names.  Specifying these CPU
     names for relevant systems will improve performance significantly.

     In general, if you want a library that runs as fast as possible,
     you should make sure you configure MP for the exact CPU type your
     system uses.

     If you have `gcc' in your `PATH', it will be used by default.  To
     override this, pass `-with-gcc=no' to `configure'.

  2. `make'

     This will compile MP, and create a library archive file `libgmp.a'
     in the working directory.

  3. `make check'

     This will make sure MP was built correctly.  If you get error
     messages, please report this to `bug-gmp@gnu.org'.  (*Note
     Reporting Bugs::, for information on what to include in useful bug
     reports.)

  4. `make install'

     This will copy the file `gmp.h' and `libgmp.a', as well as the info
     files, to `/usr/local' (or if you passed the `--prefix' option to
     `configure', to the directory given as argument to `--prefix').

If you wish to build and install the BSD MP compatible functions, use
`make libmp.a' and `make install-bsdmp'.

   There are some other useful make targets:

   * `doc'

     Create a DVI version of the manual, in `gmp.dvi' and a set of info
     files, in `gmp.info', `gmp.info-1', `gmp.info-2', etc.

   * `ps'

     Create a Postscript version of the manual, in `gmp.ps'.

   * `html'

     Create a HTML version of the manual, in `gmp.html'.

   * `clean'

     Delete all object files and archive files, but not the
     configuration files.

   * `distclean'

     Delete all files not included in the distribution.

   * `uninstall'

     Delete all files copied by `make install'.

Known Build Problems
====================

   (You might find more up-to-date information at
`http://www.matematik.su.se/~tege/gmp/'.)

   GCC 2.7.2 (or 2.6.3) for the POWER and PowerPC can not be used to
compile MP, due to a bug in GCC.  If you want to use GCC for these
machines, get GCC 2.7.2.1 (or later), or apply the patch below to GCC
and recompile GCC.

   If you are on a Sequent Symmetry, use the GNU assembler instead of
the system assembler, since the latter has serious bugs.

   The system compiler on NeXT is a massacred and old GCC, even if the
compiler calls itself `cc'.  This compiler cannot be used to build MP.
You need to get a real GCC, and install that before you compile MP.
(NeXT have fixed this in release 3.3 of their system.)

   The system C compiler under SunOS 4 has a bug that makes it
miscompile mpq/get_d.c.  Use GCC instead if plan to use the function
`mpq_get_d'.

   Please report other problems to `bug-gmp@gnu.org'.  *Note Reporting
Bugs::.

   Patch to apply to GCC 2.6.3 and 2.7.2:

     *** config/rs6000/rs6000.md	Sun Feb 11 08:22:11 1996
     --- config/rs6000/rs6000.md.new	Sun Feb 18 03:33:37 1996
     ***************
     *** 920,926 ****
          (set (match_operand:SI 0 "gpc_reg_operand" "=r")
       	(not:SI (match_dup 1)))]
         ""
     !   "nor. %0,%2,%1"
         [(set_attr "type" "compare")])
     
       (define_insn ""
     --- 920,926 ----
          (set (match_operand:SI 0 "gpc_reg_operand" "=r")
       	(not:SI (match_dup 1)))]
         ""
     !   "nor. %0,%1,%1"
         [(set_attr "type" "compare")])
     
       (define_insn ""


File: gmp.info,  Node: MP Basics,  Next: Reporting Bugs,  Prev: Installing MP,  Up: Top

MP Basics
*********

* Menu:

* Random Number Functions::

   All declarations needed to use MP are collected in the include file
`gmp.h'.  It is designed to work with both C and C++ compilers.

Nomenclature and Types
======================

In this manual, "integer" usually means a multiple precision integer, as
defined by the MP library.  The C data type for such integers is
`mpz_t'.  Here are some examples of how to declare such integers:

     mpz_t sum;
     
     struct foo { mpz_t x, y; };
     
     mpz_t vec[20];

"Rational number" means a multiple precision fraction.  The C data type
for these fractions is `mpq_t'.  For example:

     mpq_t quotient;

"Floating point number" or "Float" for short, is an arbitrary precision
mantissa with an limited precision exponent.  The C data type for such
objects is `mpf_t'.

A "limb" means the part of a multi-precision number that fits in a
single word.  (We chose this word because a limb of the human body is
analogous to a digit, only larger, and containing several digits.)
Normally a limb contains 32 or 64 bits.  The C data type for a limb is
`mp_limb_t'.

Function Classes
================

   There are six classes of functions in the MP library:

  1. Functions for signed integer arithmetic, with names beginning with
     `mpz_'.  The associated type is `mpz_t'.  There are about 100
     functions in this class.

  2. Functions for rational number arithmetic, with names beginning with
     `mpq_'.  The associated type is `mpq_t'.  There are about 20
     functions in this class, but the functions in the previous class
     can be used for performing arithmetic on the numerator and
     denominator separately.

  3. Functions for floating-point arithmetic, with names beginning with
     `mpf_'.  The associated type is `mpf_t'.  There are about 50
     functions is this class.

  4. Functions compatible with Berkeley MP, such as `itom', `madd', and
     `mult'.  The associated type is `MINT'.

  5. Fast low-level functions that operate on natural numbers.  These
     are used by the functions in the preceding groups, and you can
     also call them directly from very time-critical user programs.
     These functions' names begin with `mpn_'.  There are about 30
     (hard-to-use) functions in this class.

     The associated type is array of `mp_limb_t'.

  6. Miscellaneous functions.  Functions for setting up custom
     allocation.

MP Variable Conventions
=======================

   As a general rule, all MP functions expect output arguments before
input arguments.  This notation is based on an analogy with the
assignment operator.  (The BSD MP compatibility functions disobey this
rule, having the output argument(s) last.)

   MP allows you to use the same variable for both input and output in
the same expression.  For example, the main function for integer
multiplication, `mpz_mul', can be used like this: `mpz_mul (x, x, x)'.
This computes the square of X and puts the result back in X.

   Before you can assign to an MP variable, you need to initialize it
by calling one of the special initialization functions.  When you're
done with a variable, you need to clear it out, using one of the
functions for that purpose.  Which function to use depends on the type
of variable.  See the chapters on integer functions, rational number
functions, and floating-point functions for details.

   A variable should only be initialized once, or at least cleared out
between each initialization.  After a variable has been initialized, it
may be assigned to any number of times.

   For efficiency reasons, avoid to initialize and clear out a MP
variables in loops.  Instead, initialize it before entering the loop,
and clear it out after the loop has exited.

   Once you have initialized an MP variable, you don't need to worry
about space allocation for that variable.  All functions in MP
automatically allocate additional space when a variable does not
already have enough space.  They do not, however, reduce the space when
a smaller number is stored in the object.  Most of the time, this
policy is best, since it avoids frequent re-allocation.

MP and reentrancy
=================

   The MP code is reentrant and thred-safe, with some exceptions:

   * The function `mpf_set_default_prec' saves the selected precision in
     a global variable.

   * The function `mp_set_memory_functions' uses several global
     variables for storing the selected memory allocation functions.

   * The memory allocation functions, `malloc' and friends, that GMP
     uses unless directed to uses custom allocation, may not be
     reentrant.

   * The random number functions (`mpz_random', etc) use an underlying
     random number generator from the C library, typically `mrand48' or
     `random'.  These routines are not reentrant, since they rely on
     global state.

   If the memory allocation functions (`malloc' and friends, or
whatever functions set by a call to `mp_set_memory_functions'), are not
reentrant, MP will not be reentrant either.

Useful Macros and Constants
===========================

 - Global Constant: const int mp_bits_per_limb
     The number of bits per limb.

 - Macro: __GNU_MP_VERSION
 - Macro: __GNU_MP_VERSION_MINOR
 - Macro: __GNU_MP_VERSION_PATCHLEVEL
     The major and minor MP version, and patch level, respectively, as
     integers.  For GMP i.j, these numbers will be i, j, and 0,
     respectively.  For GMP i.j.k, these numbers will be i, j, and k,
     respectively.

Compatibility with Version 1.x
==============================

   This version of MP is upward compatible with previous versions of
MP, with a few exceptions.

  1. Integer division functions round the result differently.  The
     obsolete functions (`mpz_div', `mpz_divmod', `mpz_mdiv',
     `mpz_mdivmod', etc) now all use floor rounding (i.e., they round
     the quotient towards -infinity).  There are a lot of new functions
     for integer division, giving the user better control over the
     rounding.

  2. The function `mpz_mod' now compute the true *mod* function.

  3. The functions `mpz_powm' and `mpz_powm_ui' now use *mod* for
     reduction.

  4. The assignment functions for rational numbers do no longer
     canonicalize their results.  In the case a non-canonical result
     could arise from an assignment, the user need to insert an
     explicit call to `mpq_canonicalize'.  This change was made for
     efficiency.

  5. Output generated by `mpz_out_raw' in this release cannot be read
     by `mpz_inp_raw' in previous releases.  This change was made for
     making the file format truly portable between machines with
     different word sizes.

  6. Several `mpn' functions have changed.  But they were intentionally
     undocumented in previous releases.

  7. The functions `mpz_cmp_ui', `mpz_cmp_si', and `mpq_cmp_ui' are now
     implementated as macros, and thereby sometimes evaluate their
     arguments multiple times.

  8. The functions `mpz_pow_ui' and `mpz_ui_pow_ui' now yield 1 for
     0^0.  (In version 1, they yielded 0.)


Compatibility with Version 2.0.x
================================

   This version of MP is upward compatible with version 2.0, 2.0.1, and
2.0.2.

Getting the Latest Version of MP
================================

   The latest version of the MP library is available by at
`ftp://ftp.gnu.org/pub/gnu'.  The file name will be `gmp-I.J.tar.gz' or
`gmp-I.J.K.tar.gz'.  Many sites around the world mirror `ftp.gnu.org';
please use a mirror site near you.


File: gmp.info,  Node: Random Number Functions,  Up: MP Basics

Random Number Functions
=======================

   Hey, write something smart here!


File: gmp.info,  Node: Reporting Bugs,  Next: Integer Functions,  Prev: MP Basics,  Up: Top

Reporting Bugs
**************

   If you think you have found a bug in the MP library, please
investigate it and report it.  We have made this library available to
you, and it is not to ask too much from you, to ask you to report the
bugs that you find.

   There are a few things you should think about when you put your bug
report together.

   You have to send us a test case that makes it possible for us to
reproduce the bug.  Include instructions on how to run the test case.

   You also have to explain what is wrong; if you get a crash, or if
the results printed are incorrect and in that case, in what way.

   It is not uncommon that an observed problem is actually due to a bug
in the compiler used when building MP; the MP code tends to explore
interesting corners in compilers.  Therefore, please include compiler
version information in your bug report.  This can be extracted using
`what `which cc`', or, if you're using gcc, `gcc -v'.  Also, include
the output from `uname -a'.

   If your bug report is good, we will do our best to help you to get a
corrected version of the library; if the bug report is poor, we won't
do anything about it (aside of chiding you to send better bug reports).

   Send your bug report to: `bug-gmp@gnu.org'.

   If you think something in this manual is unclear, or downright
incorrect, or if the language needs to be improved, please send a note
to the same address.


File: gmp.info,  Node: Integer Functions,  Next: Rational Number Functions,  Prev: Reporting Bugs,  Up: Top

Integer Functions
*****************

   This chapter describes the MP functions for performing integer
arithmetic.  These functions start with the prefix `mpz_'.

   MP integers are stored in objects of type `mpz_t'.

* Menu:

* Initializing Integers::
* Assigning Integers::
* Simultaneous Integer Init & Assign::
* Converting Integers::
* Integer Arithmetic::
* Comparison Functions::
* Integer Logic and Bit Fiddling::
* I/O of Integers::
* Miscellaneous Integer Functions::


File: gmp.info,  Node: Initializing Integers,  Next: Assigning Integers,  Up: Integer Functions

Initialization and Assignment Functions
=======================================

   The functions for integer arithmetic assume that all integer objects
are initialized.  You do that by calling the function `mpz_init'.

 - Function: void mpz_init (mpz_t INTEGER)
     Initialize INTEGER with limb space and set the initial numeric
     value to 0.  Each variable should normally only be initialized
     once, or at least cleared out (using `mpz_clear') between each
     initialization.

   Here is an example of using `mpz_init':

     {
       mpz_t integ;
       mpz_init (integ);
       ...
       mpz_add (integ, ...);
       ...
       mpz_sub (integ, ...);
     
       /* Unless the program is about to exit, do ... */
       mpz_clear (integ);
     }

As you can see, you can store new values any number of times, once an
object is initialized.

 - Function: void mpz_clear (mpz_t INTEGER)
     Free the limb space occupied by INTEGER.  Make sure to call this
     function for all `mpz_t' variables when you are done with them.

 - Function: void * _mpz_realloc (mpz_t INTEGER, mp_size_t NEW_ALLOC)
     Change the limb space allocation to NEW_ALLOC limbs.  This
     function is not normally called from user code, but it can be used
     to give memory back to the heap, or to increase the space of a
     variable to avoid repeated automatic re-allocation.

 - Function: void mpz_array_init (mpz_t INTEGER_ARRAY[], size_t
          ARRAY_SIZE, mp_size_t FIXED_NUM_BITS)
     Allocate *fixed* limb space for all ARRAY_SIZE integers in
     INTEGER_ARRAY.  The fixed allocation for each integer in the array
     is enough to store FIXED_NUM_BITS.  If the fixed space will be
     insufficient for storing the result of a subsequent calculation,
     the result is unpredictable.

     This function is useful for decreasing the working set for some
     algorithms that use large integer arrays.

     There is no way to de-allocate the storage allocated by this
     function.  Don't call `mpz_clear'!


File: gmp.info,  Node: Assigning Integers,  Next: Simultaneous Integer Init & Assign,  Prev: Initializing Integers,  Up: Integer Functions

Assignment Functions
--------------------

   These functions assign new values to already initialized integers
(*note Initializing Integers::.).

 - Function: void mpz_set (mpz_t ROP, mpz_t OP)
 - Function: void mpz_set_ui (mpz_t ROP, unsigned long int OP)
 - Function: void mpz_set_si (mpz_t ROP, signed long int OP)
 - Function: void mpz_set_d (mpz_t ROP, double OP)
 - Function: void mpz_set_q (mpz_t ROP, mpq_t OP)
 - Function: void mpz_set_f (mpz_t ROP, mpf_t OP)
     Set the value of ROP from OP.

 - Function: int mpz_set_str (mpz_t ROP, char *STR, int BASE)
     Set the value of ROP from STR, a '\0'-terminated C string in base
     BASE.  White space is allowed in the string, and is simply
     ignored.  The base may vary from 2 to 36.  If BASE is 0, the
     actual base is determined from the leading characters: if the
     first two characters are `0x' or `0X', hexadecimal is assumed,
     otherwise if the first character is `0', octal is assumed,
     otherwise decimal is assumed.

     This function returns 0 if the entire string up to the '\0' is a
     valid number in base BASE.  Otherwise it returns -1.

 - Function: void mpz_swap (mpz_t ROP1, mpz_t ROP2)
     Swap the values ROP1 and ROP2 efficiently.


File: gmp.info,  Node: Simultaneous Integer Init & Assign,  Next: Converting Integers,  Prev: Assigning Integers,  Up: Integer Functions

Combined Initialization and Assignment Functions
------------------------------------------------

   For convenience, MP provides a parallel series of initialize-and-set
functions which initialize the output and then store the value there.
These functions' names have the form `mpz_init_set...'

   Here is an example of using one:

     {
       mpz_t pie;
       mpz_init_set_str (pie, "3141592653589793238462643383279502884", 10);
       ...
       mpz_sub (pie, ...);
       ...
       mpz_clear (pie);
     }

Once the integer has been initialized by any of the `mpz_init_set...'
functions, it can be used as the source or destination operand for the
ordinary integer functions.  Don't use an initialize-and-set function
on a variable already initialized!

 - Function: void mpz_init_set (mpz_t ROP, mpz_t OP)
 - Function: void mpz_init_set_ui (mpz_t ROP, unsigned long int OP)
 - Function: void mpz_init_set_si (mpz_t ROP, signed long int OP)
 - Function: void mpz_init_set_d (mpz_t ROP, double OP)
     Initialize ROP with limb space and set the initial numeric value
     from OP.

 - Function: int mpz_init_set_str (mpz_t ROP, char *STR, int BASE)
     Initialize ROP and set its value like `mpz_set_str' (see its
     documentation above for details).

     If the string is a correct base BASE number, the function returns
     0; if an error occurs it returns -1.  ROP is initialized even if
     an error occurs.  (I.e., you have to call `mpz_clear' for it.)


File: gmp.info,  Node: Converting Integers,  Next: Integer Arithmetic,  Prev: Simultaneous Integer Init & Assign,  Up: Integer Functions

Conversion Functions
====================

   This section describes functions for converting MP integers to
standard C types.  Functions for converting *to* MP integers are
described in *Note Assigning Integers:: and *Note I/O of Integers::.

 - Function: mp_limb_t mpz_getlimbn (mpz_t OP, mp_size_t N)
     Return limb #N from OP.  This function allows for very efficient
     decomposition of a number in its limbs.

     The function `mpz_size' can be used to determine the useful range
     for N.

 - Function: unsigned long int mpz_get_ui (mpz_t OP)
     Return the least significant part from OP.  This function combined
     with
     `mpz_tdiv_q_2exp(..., OP, CHAR_BIT*sizeof(unsigned long int))' can
     be used to decompose an integer into unsigned longs.

 - Function: signed long int mpz_get_si (mpz_t OP)
     If OP fits into a `signed long int' return the value of OP.
     Otherwise return the least significant part of OP, with the same
     sign as OP.

     If OP is too large to fit in a `signed long int', the returned
     result is probably not very useful.

 - Function: double mpz_get_d (mpz_t OP)
     Convert OP to a double.

 - Function: char * mpz_get_str (char *STR, int BASE, mpz_t OP)
     Convert OP to a string of digits in base BASE.  The base may vary
     from 2 to 36.

     If STR is NULL, space for the result string is allocated using the
     default allocation function, and a pointer to the string is
     returned.

     If STR is not NULL, it should point to a block of storage enough
     large for the result.  To find out the right amount of space to
     provide for STR, use `mpz_sizeinbase (OP, BASE) + 2'.  The two
     extra bytes are for a possible minus sign, and for the terminating
     null character.


File: gmp.info,  Node: Integer Arithmetic,  Next: Comparison Functions,  Prev: Converting Integers,  Up: Integer Functions

Arithmetic Functions
====================

 - Function: void mpz_add (mpz_t ROP, mpz_t OP1, mpz_t OP2)
 - Function: void mpz_add_ui (mpz_t ROP, mpz_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 + OP2.

 - Function: void mpz_sub (mpz_t ROP, mpz_t OP1, mpz_t OP2)
 - Function: void mpz_sub_ui (mpz_t ROP, mpz_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 - OP2.

 - Function: void mpz_mul (mpz_t ROP, mpz_t OP1, mpz_t OP2)
 - Function: void mpz_mul_ui (mpz_t ROP, mpz_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 times OP2.

 - Function: void mpz_addmul_ui (mpz_t ROP, mpz_t OP1, unsigned long
          int OP2)
     Add OP1 times OP2 to ROP.

 - Function: void mpz_mul_2exp (mpz_t ROP, mpz_t OP1, unsigned long int
          OP2)
     Set ROP to OP1 times 2 raised to OP2.  This operation can also be
     defined as a left shift, OP2 steps.

 - Function: void mpz_neg (mpz_t ROP, mpz_t OP)
     Set ROP to -OP.

 - Function: void mpz_abs (mpz_t ROP, mpz_t OP)
     Set ROP to the absolute value of OP.

Division and mod functions
--------------------------

   Division is undefined if the divisor is zero, and passing a zero
divisor to the divide or modulo functions, as well passing a zero mod
argument to the `mpz_powm' and `mpz_powm_ui' functions, will make these
functions intentionally divide by zero.  This gives the user the
possibility to handle arithmetic exceptions in these functions in the
same manner as other arithmetic exceptions.

   There are three main groups of division functions:
   * Functions that truncate the quotient towards 0.  The names of
     these functions start with `mpz_tdiv'.  The `t' in the name is
     short for `truncate'.

   * Functions that round the quotient towards -infinity).  The names
     of these routines start with `mpz_fdiv'.  The `f' in the name is
     short for `floor'.

   * Functions that round the quotient towards +infinity.  The names of
     these routines start with `mpz_cdiv'.  The `c' in the name is
     short for `ceil'.

   For each rounding mode, there are a couple of variants.  Here `q'
means that the quotient is computed, while `r' means that the remainder
is computed.  Functions that compute both the quotient and remainder
have `qr' in the name.

 - Function: void mpz_tdiv_q (mpz_t Q, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_tdiv_q_ui (mpz_t Q, mpz_t N,
          unsigned long int D)
     Set Q to [N/D], truncated towards 0.  The function `mpz_tdiv_q_ui'
     returns the absolute value of remainder.

     The function `mpz_tdiv_q_ui' returns the absolute value of the
     remainder.

 - Function: void mpz_tdiv_r (mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_tdiv_r_ui (mpz_t R, mpz_t N,
          unsigned long int D)
     Set R to (N - [N/D] * D), where the quotient is truncated towards
     0.  Unless R becomes zero, it will get the same sign as N.

     The function `mpz_tdiv_r_ui' returns the absolute value of the
     remainder.

 - Function: void mpz_tdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_tdiv_qr_ui (mpz_t Q, mpz_t R, mpz_t
          N, unsigned long int D)
     Set Q to [N/D], truncated towards 0.  Set R to (N - [N/D] * D).
     Unless R becomes zero, it will get the same sign as N.  If Q and R
     are the same variable, the results are undefined.

     The function `mpz_tdiv_qr_ui' returns the absolute value of the
     remainder.

 - Function: unsigned long int mpz_tdiv_ui (mpz_t N, unsigned long int
          D)
     Like `mpz_tdiv_r_ui', but the remainder is not stored anywhere; its
     absolute value is just returned.

 - Function: void mpz_fdiv_q (mpz_t Q, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_fdiv_q_ui (mpz_t Q, mpz_t N,
          unsigned long int D)
     Set Q to N/D, rounded towards -infinity.

     The function `mpz_fdiv_q_ui' returns the remainder.

 - Function: void mpz_fdiv_r (mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_fdiv_r_ui (mpz_t R, mpz_t N,
          unsigned long int D)
     Set R to (N - N/D * D), where the quotient is rounded towards
     -infinity.  Unless R becomes zero, it will get the same sign as D.

     The function `mpz_fdiv_r_ui' returns the remainder.

 - Function: void mpz_fdiv_qr (mpz_t R, mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_fdiv_qr_ui (mpz_t Q, mpz_t R, mpz_t
          N, unsigned long int D)
     Set Q to N/D, rounded towards -infinity.  Set R to (N - N/D * D).
     Unless R becomes zero, it will get the same sign as D.  If Q and R
     are the same variable, the results are undefined.

     The function `mpz_fdiv_qr_ui' returns the remainder.

 - Function: unsigned long int mpz_fdiv_ui (mpz_t N, unsigned long int
          D)
     Like `mpz_fdiv_r_ui', but the remainder is not stored anywhere; it
     is just returned.

 - Function: void mpz_cdiv_q (mpz_t Q, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_cdiv_q_ui (mpz_t Q, mpz_t N,
          unsigned long int D)
     Set Q to N/D, rounded towards +infinity.

     The function `mpz_cdiv_q_ui' returns the negated remainder.

 - Function: void mpz_cdiv_r (mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_cdiv_r_ui (mpz_t R, mpz_t N,
          unsigned long int D)
     Set R to (N - N/D * D), where the quotient is rounded towards
     +infinity.  Unless R becomes zero, it will get the opposite sign
     as D.

     The function `mpz_cdiv_r_ui' returns the negated remainder.

 - Function: void mpz_cdiv_qr (mpz_t Q, mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_cdiv_qr_ui (mpz_t Q, mpz_t R, mpz_t
          N, unsigned long int D)
     Set Q to N/D, rounded towards +infinity.  Set R to (N - N/D * D).
     Unless R becomes zero, it will get the opposite sign as D.  If Q
     and R are the same variable, the results are undefined.

     The function `mpz_cdiv_qr_ui' returns the negated remainder.

 - Function: unsigned long int mpz_cdiv_ui (mpz_t N, unsigned long int
          D)
     Like `mpz_tdiv_r_ui', but the remainder is not stored anywhere; its
     negated value is just returned.

 - Function: void mpz_mod (mpz_t R, mpz_t N, mpz_t D)
 - Function: unsigned long int mpz_mod_ui (mpz_t R, mpz_t N, unsigned
          long int D)
     Set R to N `mod' D.  The sign of the divisor is ignored; the
     result is always non-negative.

     The function `mpz_mod_ui' returns the remainder.

 - Function: void mpz_divexact (mpz_t Q, mpz_t N, mpz_t D)
     Set Q to N/D.  This function produces correct results only when it
     is known in advance that D divides N.

     Since mpz_divexact is much faster than any of the other routines
     that produce the quotient (*note References::. Jebelean), it is
     the best choice for instances in which exact division is known to
     occur, such as reducing a rational to lowest terms.

 - Function: void mpz_tdiv_q_2exp (mpz_t Q, mpz_t N, unsigned long int
          D)
     Set Q to N divided by 2 raised to D.  The quotient is truncated
     towards 0.

 - Function: void mpz_tdiv_r_2exp (mpz_t R, mpz_t N, unsigned long int
          D)
     Divide N by (2 raised to D) and put the remainder in R.  Unless it
     is zero, R will have the same sign as N.

 - Function: void mpz_fdiv_q_2exp (mpz_t Q, mpz_t N, unsigned long int
          D)
     Set Q to N divided by 2 raised to D, rounded towards -infinity.

 - Function: void mpz_fdiv_r_2exp (mpz_t R, mpz_t N, unsigned long int
          D)
     Divide N by (2 raised to D) and put the remainder in R.  The sign
     of R will always be positive.

     This operation can also be defined as masking of the D least
     significant bits.

Exponentiation Functions
------------------------

 - Function: void mpz_powm (mpz_t ROP, mpz_t BASE, mpz_t EXP, mpz_t MOD)
 - Function: void mpz_powm_ui (mpz_t ROP, mpz_t BASE, unsigned long int
          EXP, mpz_t MOD)
     Set ROP to (BASE raised to EXP) `mod' MOD.  If EXP is negative,
     the result is undefined.

 - Function: void mpz_pow_ui (mpz_t ROP, mpz_t BASE, unsigned long int
          EXP)
 - Function: void mpz_ui_pow_ui (mpz_t ROP, unsigned long int BASE,
          unsigned long int EXP)
     Set ROP to BASE raised to EXP.  The case of 0^0 yields 1.

Root Functions
--------------

 - Function: void mpz_root (mpz_t ROP, mpz_t OP, unsigned long int N)
     Set ROP to the truncated integer part of the Nth root of OP.

 - Function: void mpz_sqrt (mpz_t ROP, mpz_t OP)
     Set ROP to the truncated integer part of the square root of OP.

 - Function: void mpz_sqrtrem (mpz_t ROP1, mpz_t ROP2, mpz_t OP)
     Set ROP1 to the truncated integer part of the square root of OP,
     like `mpz_sqrt'.  Set ROP2 to OP-ROP1*ROP1, (i.e., zero if OP is a
     perfect square).

     If ROP1 and ROP2 are the same variable, the results are undefined.

 - Function: int mpz_perfect_power_p (mpz_t OP)
     Return non-zero if OP is a perfect power, i.e., if there exist
     integers A and B, with B > 1, such that OP equals a raised to b.
     Return zero otherwise.

 - Function: int mpz_perfect_square_p (mpz_t OP)
     Return non-zero if OP is a perfect square, i.e., if the square
     root of OP is an integer.  Return zero otherwise.

Number Theoretic Functions
--------------------------

 - Function: int mpz_probab_prime_p (mpz_t N, int REPS)
     If this function returns 0, N is definitely not prime.  If it
     returns 1, then N is `probably' prime.  If it returns 2, then N is
     surely prime.  Reasonable values of reps vary from 5 to 10; a
     higher value lowers the probability for a non-prime to pass as a
     `probable' prime.

     The function uses Miller-Rabin's probabilistic test.

 - Function: int mpz_prime_p (mpz_t N)
     Return non-zero if N is prime and zero if N is a non-prime.  This
     function is far slower than `mpz_probab_prime_p', but then it
     never returns non-zero for composite numbers.

     (For practical purposes, using `mpz_probab_prime_p' is adequate.
     The likelyhood of a programming error or hardware malfunction is
     orders of magnitudes greater than the likelyhood for a composite
     to pass as a prime, if the REPS argument is in the suggested
     range.)

 - Function: void mpz_gcd (mpz_t ROP, mpz_t OP1, mpz_t OP2)
     Set ROP to the greatest common divisor of OP1 and OP2.  The result
     is always positive even if either of or both input operands are
     negative.

 - Function: unsigned long int mpz_gcd_ui (mpz_t ROP, mpz_t OP1,
          unsigned long int OP2)
     Compute the greatest common divisor of OP1 and OP2.  If ROP is not
     NULL, store the result there.

     If the result is small enough to fit in an `unsigned long int', it
     is returned.  If the result does not fit, 0 is returned, and the
     result is equal to the argument OP1.  Note that the result will
     always fit if OP2 is non-zero.

 - Function: void mpz_gcdext (mpz_t G, mpz_t S, mpz_t T, mpz_t A, mpz_t
          B)
     Compute G, S, and T, such that AS + BT = G = `gcd'(A, B).  If T is
     NULL, that argument is not computed.

 - Function: void mpz_lcm (mpz_t ROP, mpz_t OP1, mpz_t OP2)
     Set ROP to the least common multiple of OP1 and OP2.

 - Function: int mpz_invert (mpz_t ROP, mpz_t OP1, mpz_t OP2)
     Compute the inverse of OP1 modulo OP2 and put the result in ROP.
     Return non-zero if an inverse exist, zero otherwise.  When the
     function returns zero, ROP is undefined.

 - Function: int mpz_jacobi (mpz_t OP1, mpz_t OP2)
 - Function: int mpz_legendre (mpz_t OP1, mpz_t OP2)
     Compute the Jacobi and Legendre symbols, respectively.

 - Function: unsigned long int mpz_remove (mpz_t ROP, mpz_t OP, mpz_t F)
     Remove all occurences of the factor F from OP and store the result
     in ROP.  Return the multiplicity of F in OP.

 - Function: void mpz_fac_ui (mpz_t ROP, unsigned long int OP)
     Set ROP to OP!, the factorial of OP.

 - Function: void mpz_bin_ui (mpz_t ROP, mpz_t N, unsigned long int K)
 - Function: void mpz_bin_uiui (mpz_t ROP, unsigned long int N,
          unsigned long int K)
     Compute the binomial coefficient N over K and store the result in
     ROP.

 - Function: void mpz_fib_ui (mpz_t ROP, unsigned long int N)
     Compute the Nth Fibonacci number and store the result in ROP.


File: gmp.info,  Node: Comparison Functions,  Next: Integer Logic and Bit Fiddling,  Prev: Integer Arithmetic,  Up: Integer Functions

Comparison Functions
====================

 - Function: int mpz_cmp (mpz_t OP1, mpz_t OP2)
     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
     if OP1 = OP2, and a negative value if OP1 < OP2.

 - Macro: int mpz_cmp_ui (mpz_t OP1, unsigned long int OP2)
 - Macro: int mpz_cmp_si (mpz_t OP1, signed long int OP2)
     Compare OP1 and OP2.  Return a positive value if OP1 > OP2, zero
     if OP1 = OP2, and a negative value if OP1 < OP2.

     These functions are actually implemented as macros.  They evaluate
     their arguments multiple times.

 - Function: int mpz_cmp_abs (mpz_t OP1, mpz_t OP2)
 - Function: int mpz_cmp_abs_ui (mpz_t OP1, unsigned long int OP2)
     Compare the absolute values of OP1 and OP2.  Return a positive
     value if OP1 > OP2, zero if OP1 = OP2, and a negative value if OP1
     < OP2.

 - Macro: int mpz_sgn (mpz_t OP)
     Return +1 if OP > 0, 0 if OP = 0, and -1 if OP < 0.

     This function is actually implemented as a macro.  It evaluates its
     arguments multiple times.


File: gmp.info,  Node: Integer Logic and Bit Fiddling,  Next: I/O of Integers,  Prev: Comparison Functions,  Up: Integer Functions

Logical and Bit Manipulation Functions
======================================

   These functions behave as if two's complement arithmetic were used
(although sign-magnitude is used by the actual implementation).

 - Function: void mpz_and (mpz_t ROP, mpz_t OP1, mpz_t OP2)
     Set ROP to OP1 logical-and OP2.

 - Function: void mpz_ior (mpz_t ROP, mpz_t OP1, mpz_t OP2)
     Set ROP to OP1 inclusive-or OP2.

 - Function: void mpz_xor (mpz_t ROP, mpz_t OP1, mpz_t OP2)
     Set ROP to OP1 exclusive-or OP2.

 - Function: void mpz_com (mpz_t ROP, mpz_t OP)
     Set ROP to the one's complement of OP.

 - Function: unsigned long int mpz_popcount (mpz_t OP)
     For non-negative numbers, return the population count of OP.  For
     negative numbers, return the largest possible value (MAX_ULONG).

 - Function: unsigned long int mpz_hamdist (mpz_t OP1, mpz_t OP2)
     If OP1 and OP2 are both non-negative, return the hamming distance
     between the two operands.  Otherwise, return the largest possible
     value (MAX_ULONG).

     It is possible to extend this function to return a useful value
     when the operands are both negative, but the current
     implementation returns MAX_ULONG in this case.  *Do not depend on
     this behavior, since it will change in a future release.*

 - Function: unsigned long int mpz_scan0 (mpz_t OP, unsigned long int
          STARTING_BIT)
     Scan OP, starting with bit STARTING_BIT, towards more significant
     bits, until the first clear bit is found.  Return the index of the
     found bit.

 - Function: unsigned long int mpz_scan1 (mpz_t OP, unsigned long int
          STARTING_BIT)
     Scan OP, starting with bit STARTING_BIT, towards more significant
     bits, until the first set bit is found.  Return the index of the
     found bit.

 - Function: void mpz_setbit (mpz_t ROP, unsigned long int BIT_INDEX)
     Set bit BIT_INDEX in ROP.

 - Function: void mpz_clrbit (mpz_t ROP, unsigned long int BIT_INDEX)
     Clear bit BIT_INDEX in ROP.

 - Function: int mpz_tstbit (mpz_t OP, unsigned long int BIT_INDEX)
     Check bit BIT_INDEX in OP and return 0 or 1 accordingly.


File: gmp.info,  Node: I/O of Integers,  Next: Miscellaneous Integer Functions,  Prev: Integer Logic and Bit Fiddling,  Up: Integer Functions

Input and Output Functions
==========================

   Functions that perform input from a stdio stream, and functions that
output to a stdio stream.  Passing a NULL pointer for a STREAM argument
to any of these functions will make them read from `stdin' and write to
`stdout', respectively.

   When using any of these functions, it is a good idea to include
`stdio.h' before `gmp.h', since that will allow `gmp.h' to define
prototypes for these functions.

 - Function: size_t mpz_out_str (FILE *STREAM, int BASE, mpz_t OP)
     Output OP on stdio stream STREAM, as a string of digits in base
     BASE.  The base may vary from 2 to 36.

     Return the number of bytes written, or if an error occurred,
     return 0.

 - Function: size_t mpz_inp_str (mpz_t ROP, FILE *STREAM, int BASE)
     Input a possibly white-space preceded string in base BASE from
     stdio stream STREAM, and put the read integer in ROP.  The base
     may vary from 2 to 36.  If BASE is 0, the actual base is
     determined from the leading characters: if the first two
     characters are `0x' or `0X', hexadecimal is assumed, otherwise if
     the first character is `0', octal is assumed, otherwise decimal is
     assumed.

     Return the number of bytes read, or if an error occurred, return 0.

 - Function: size_t mpz_out_raw (FILE *STREAM, mpz_t OP)
     Output OP on stdio stream STREAM, in raw binary format.  The
     integer is written in a portable format, with 4 bytes of size
     information, and that many bytes of limbs.  Both the size and the
     limbs are written in decreasing significance order (i.e., in
     big-endian).

     The output can be read with `mpz_inp_raw'.

     Return the number of bytes written, or if an error occurred,
     return 0.

     The output of this can not be read by `mpz_inp_raw' from GMP 1,
     because of changes necessary for compatibility between 32-bit and
     64-bit machines.

 - Function: size_t mpz_inp_raw (mpz_t ROP, FILE *STREAM)
     Input from stdio stream STREAM in the format written by
     `mpz_out_raw', and put the result in ROP.  Return the number of
     bytes read, or if an error occurred, return 0.

     This routine can read the output from `mpz_out_raw' also from GMP
     1, in spite of changes necessary for compatibility between 32-bit
     and 64-bit machines.


File: gmp.info,  Node: Miscellaneous Integer Functions,  Prev: I/O of Integers,  Up: Integer Functions

Miscellaneous Functions
=======================

   The random number functions of GMP come in two groups; older function
that rely on a global state, and newer functions that accept a state
parameter that is read and modified.  Please see the *Note Random
Number Functions:: for more information on how to use and not to use
random number functions.

 - Function: void mpz_random (mpz_t ROP, mp_size_t MAX_SIZE)
     Generate a random integer of at most MAX_SIZE limbs.  The generated
     random number doesn't satisfy any particular requirements of
     randomness.  Negative random numbers are generated when MAX_SIZE
     is negative.

     This function is obsolete.  Use `mpz_urandomb' or `mpz_urandomm'
     instead.

 - Function: void mpz_random2 (mpz_t ROP, mp_size_t MAX_SIZE)
     Generate a random integer of at most MAX_SIZE limbs, with long
     strings of zeros and ones in the binary representation.  Useful
     for testing functions and algorithms, since this kind of random
     numbers have proven to be more likely to trigger corner-case bugs.
     Negative random numbers are generated when MAX_SIZE is negative.

     This function is obsolete.  Use `mpz_rrandomb' instead.

 - Function: void mpz_urandomb (mpz_t ROP, unsigned long int N, mpz_t
          STATE)
     Generate a uniform random integer in the range 0 to 2^N - 1,
     inclusive.

     The variable STATE is used as a seed for generating the random
     number.  It is updated with a new seed.

 - Function: void mpz_urandomm (mpz_t ROP, mpz_t N, mpz_t STATE)
     Generate a uniform random integer in the range 0 to N

     The variable STATE is used as a seed for generating the random
     number.  It is updated with a new seed.

 - Function: void mpz_rrandomb (mpz_t ROP, unsigned long int N, mpz_t
          STATE)
     Generate a random integer with long strings of zeros and ones in
     the binary representation.  Useful for testing functions and
     algorithms, since this kind of random numbers have proven to be
     more likely to trigger corner-case bugs.  The random number will
     be in the range 0 to 2^N - 1, inclusive.

     The variable STATE is used as a seed for generating the random
     number.  It is updated with a new seed.  Unlike other random number
     functions, the STATE variable should probably be much smaller than
     the generated numbers, since the generated random numbers are of
     such special nature.  In fact, it should probably be kept under
     2^100.

 - Function: size_t mpz_size (mpz_t OP)
     Return the size of OP measured in number of limbs.  If OP is zero,
     the returned value will be zero.

 - Function: size_t mpz_sizeinbase (mpz_t OP, int BASE)
     Return the size of OP measured in number of digits in base BASE.
     The base may vary from 2 to 36.  The returned value will be exact
     or 1 too big.  If BASE is a power of 2, the returned value will
     always be exact.

     This function is useful in order to allocate the right amount of
     space before converting OP to a string.  The right amount of
     allocation is normally two more than the value returned by
     `mpz_sizeinbase' (one extra for a minus sign and one for the
     terminating '\0').


File: gmp.info,  Node: Rational Number Functions,  Next: Floating-point Functions,  Prev: Integer Functions,  Up: Top

Rational Number Functions
*************************

   This chapter describes the MP functions for performing arithmetic on
rational numbers.  These functions start with the prefix `mpq_'.

   Rational numbers are stored in objects of type `mpq_t'.

   All rational arithmetic functions assume operands have a canonical
form, and canonicalize their result.  The canonical from means that the
denominator and the numerator have no common factors, and that the
denominator is positive.  Zero has the unique representation 0/1.

   Pure assignment functions do not canonicalize the assigned variable.
It is the responsibility of the user to canonicalize the assigned
variable before any arithmetic operations are performed on that
variable.  *Note that this is an incompatible change from version 1 of
the library.*

 - Function: void mpq_canonicalize (mpq_t OP)
     Remove any factors that are common to the numerator and
     denominator of OP, and make the denominator positive.

* Menu:

* Initializing Rationals::
* Assigning Rationals::
* Simultaneous Integer Init & Assign::
* Comparing Rationals::
* Applying Integer Functions::
* Miscellaneous Rational Functions::

